---
title: Haskell
layout: post
---

Short post! I've been learning some Haskell when I have downtime between other projects and want to spend time with my head in a book working out problems. As part of the learning experience, I like to implement algorithms that I'm already familiar with. One that's pretty standard (and that, admittedly, I had heard was simple in Haskell) that I wanted to implement was QuickSort. And boy, what a delight that was to implement!

Due to its recursive nature, Haskell makes implementing QuickSort downright trivial, to the point that I wish that I had originally been taught the algorithm with an explanation in this language.

{% highlight haskell %}

quickSort :: [Integer] -> [Integer]
quickSort [] = []
quickSort (x:xs) = quickSort ( filter (<= x) xs )
    ++ [x] ++ quickSort (filter (>= x) xs )

{% endhighlight %}

The first line defines the function, and says that it takes an Integer array and returns an Integer array. Pretty simple and pretty obvious considering what QuickSort does.
The second line is our base case. If we're sorting an empty list, return an empty list.
The final line is where the magic happens. For simplicity we choose the first element `x` as our pivot. Using the rule `<= x` for the left side of the sort and `>=x` for the right side, and filter to quickly create the two sides of the sort, we then recursively apply QuickSort to the two filtered lists, append them on either side of the pivot, and that's it.

And that's pretty damn cool.
